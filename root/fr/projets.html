<a href="/en/projects.html" class="big-link">[ English version ]</a>

<h1>Projets</h1>

<p>
    Cliquez sur les titres de projets pour afficher les détails.
</p>

<details>
    <summary>jvWhiteboard<span class="tags">[Javascript] [WebRTC] [Python]</span></summary>
    <p>
        Afin d'expérimenter avec les WebRTC (technologie peer-to-peer pour le Web), j'ai créé une
        application de réunion à distance nommée <strong>jvWhiteboard</strong>, accessible
        <a href="https://experiments.jvernay.fr/whiteboard/fr/">sur mon site</a>.
    </p>
    <p>
        Un utilisateur peut créer une salle de réunion. Un ID lui est donné, qu'il peut
        partager à d'autres utilisateurs afin de rejoindre cette salle de réunion.
        Une fois que les utilisateurs rejoignent la réunion, ils peuvent diffuser leur caméra et audio,
        discuter textuellement, partager des fichiers et dessiner de façon collaborative.
        Hormis la création et la connexion aux salles (qui nécessite un serveur de signaling), toutes
        les interactions entre utilisateurs sont en peer-to-peer avec WebRTC (donc cryptées).
    </p>
    <p>
        Pour réaliser ce projet, j'ai utilisé les technologies standards HTML5/CSS3/Javascript,
        sans framework. J'ai utilisé deux bibliothèques externes (SVG.js et saveSvgAsPng.js) qui
        m'ont évité la manipulation directe des dessins. J'ai implémenté le reste du frontend
        (signaling avec Websockets, caméras, synchronisation du dessin, discussion, partage de fichiers, etc)
        par moi-même directement depuis les APIs standard du Web.
    </p>
    <p>
        Pour la partie backend, j'utilise un serveur scripté en Python avec la bibliothèque websockets,
        qui s'occupe de garder une connexion avec tous les utilisateurs d'une salle et de transmettre
        les négociations entre utilisateurs (quelle IP utiliser pour joindre les autres,
        quel codec pour envoyer la vidéo, etc).
    </p>
    <figure>
        <figcaption>Vidéo de démonstration</figcaption>
        <video controls width="80%">
            <source src="/common/assets/projects/jvWhiteboard.mp4" type="video/mp4">
        </video>
    </figure>
    <p>
        Les sources sont disponibles en AGPL sur <a href="https://github.com/jvernay-fr/experiments.jvernay.fr">GitHub</a>.
    </p>
</details>

<details>
    <summary>Figée dans le passé<span class="tags">[Game Jam] [Godot Engine]</span></summary>
    <p>
        J'ai participé avec un ami à la WonderJam UQAC 2021, une Game Jam organisée par l'Université du
        Québec À Chicoutimi, et propulsée par Ubisoft Saguenay.
        Le thème était <strong>Résistance</strong>, et nous avions trois contraintes de gameplay:
        <em>Arcade, Versus, Physics-based</em>.
        Nous avons créé <strong>Figée dans le passé</strong>, jouable dans le navigateur sur <a href="https://julien-vernay.itch.io/figee-dans-le-passe">itch.io</a>.
        L'objectif est de s'enfuir le plus vite possible, dans un puzzle-platformer 2D basé sur la physique.
        Hormis sauter, deux actions sont disponibles : frapper des boîtes pour les projeter, et
        figer les boîtes que l'on vient de projeter.
    </p><p>
        Le jeu a été créé avec Godot Engine, et son langage de script GDScript.
        Nous étions deux, et nous avons chacun participé à tous les aspects: déplacements du personnage,
        la physique, le mode deux joueurs, le level design, etc. Les musiques et les graphismes
        proviennent d'ailleurs (cf. CREDITS.txt dans les sources).
    </p>
    <figure>
        <figcaption>Vidéo de démonstration</figcaption>
        <video controls width="80%">
            <source src="/common/assets/projects/figee.mp4" type="video/mp4">
        </video>
    </figure>
    <p>
        Les sources sont disponibles sur <a href="https://github.com/J-Vernay/wonderjam-hiver2021">GitHub</a>.
    </p>
</details>

<details>
    <summary>Simulation de systèmes - Ascenseurs<span class="tags">[Simulation] [Javascript]</span></summary>
    <p>
        Durant mes cours de simulation de systèmes à l'UQAC, j'ai dû créer une simulation afin de
        répondre à la question: <q>Quelles seraient les répercussions de l'ajout d'un troisième ascenseur
        dans un bâtiment à 7 étages ?</q> J'ai développé une simulation afin d'observer ces répercussions.
        Plus d'informations sont disponibles sur <a href="/fr/simu-proj/">la page de la simulation</a>.
    </p>
</details>

<details>
    <summary>Crowd Control<span class="tags">[Game Jam] [Godot Engine]</span></summary>
    <p>
        En juillet 2020, j'ai participé avec deux amis à la Game Jam GMTK, dont le thème était <strong>Out of Control</strong>.
        Le jeu en résultant est <strong>Crowd Control</strong>, jouable dans le navigateur sur <a href="https://nitsugua.itch.io/crowd-control">itch.io</a>.
        Dans ce jeu, vous devez contrôler la foule afin qu'elle aille sur la zone qui lui est désignée.
        Pour cela, vous utilisez votre souris, qui possède trois actions :
    </p><ul>
        <li>Clic gauche : regrouper la foule vers le centre de la zone</li>
        <li>Clic droit : disperser la foule à l'extérieur de la zone</li>
        <li>Molette : modifier le rayon de la zone</li>
    </ul><p>
        Le jeu a été créé avec Godot Engine, et son langage de script GDScript.
        Dans ce projet, je me suis occupé de coder la foule.
        Les personnes suivent une simulation de Boids modifiée :
        un biais est rajouté dû la zone du curseur (qui peut regrouper et disperser la foule),
        et il y a deux catégories de personnes (les blonds et les bruns) qui ne s'influent pas entre elles.
        Les zones de destination comptent le nombre de personnes à l'intérieur, et déclenchent
        la fin du niveau si le nombre de personnes correspond à ce qui était attendu.
    </p>
    <figure>
        <figcaption>Vidéo de démonstration</figcaption>
        <video controls width="80%">
            <source src="/common/assets/projects/crowd_control.mp4" type="video/mp4">
        </video>
    </figure>
    <p>
        Les sources sont disponibles sur <a href="https://github.com/arnette-thomas/gmtkjam20">GitHub</a>.
    </p>
</details>

<details>
    <summary>Ariane Simulator<span class="tags">[C++] [OpenCV] [Traitement d'image]</span></summary>
    <p>
        Pour un projet d'études, avec un collègue nous avons créé le jeu <strong>Ariane Simulator</strong>.
        Il s'agit d'un jeu de labyrinthe à la première personne où l'on se déplace en faisant varier l'orientation de sa tête.
        En effet, on détecte plusieurs positions de tête qui correspondent à un mouvement dans le jeu.
    </p>
    <figure>
        <img src="/common/assets/projects/ariane_pos.png" style="width: 80%"/>
    </figure>
    <p>
        Le projet a été fait en C++ en utilisant Qt, OpenGL et OpenCV.
        Je me suis occupé de la partie traitement d'images. Avec OpenCV, je récupère les images de la caméra.
        Puis je recherche le visage et le nez. La base de la détection est d'utiliser des cascades de Haar pré-entrainées.
        Cependant quelques modifications ont dû être faite pour répondre aux besoins de notre application.
        La cascade de Haar pour le nez est entraîné sur des visages de face. Or, nous avons aussi besoin de
        détecter le nez vu de côté, puisque l'orientation du visage va changer.
        Puisque nous utilisons un flux vidéo, j'utilise la corrélation avec un nez précédemment trouvé
        dans le cas où la cascade de Haar ne fonctionne pas.
    </p>
    <figure>
        <figcaption>Vidéo de démonstration</figcaption>
        <video controls width="80%">
            <source src="/common/assets/projects/ArianeSimulator.mp4" type="video/mp4" width="600" style="width: 100%">
        </video>
    </figure>
    <p>
        Les sources sont disponibles sur <a href="https://github.com/J-Vernay/Ariane-simulator-NX-move">GitHub</a>.
    </p>
</details>

<details>
    <summary>Thomas Chronicles<span class="tags">[C++] [SFML]</span></summary>
    <p>
        Pendant les vacances d'été 2019, et pour fêter l'anniversaire d'un ami, j'ai créé le jeu <strong>Thomas Chronicles</strong>.
        C'est un jeu d'énigmes grandement inspiré par Professeur Layton. Certaines énigmes ont des
        <em>gameplay</em> particuliers, comme un taquin par exemple, tandis que d'autres demandent simplement d'entrer la réponse.
    </p><p>
        Le jeu a été créé entièrement en C++ avec SFML, et a été débogué sous Windows et GNU/Linux.
        L'objectif était aussi de faire un jeu bien poli, et je suis satisfait du résultat.
        Notamment, il y a de nombreuses transitions : fondus, défilements, etc.
        Dû à cela, le code contient de nombreuses machines d'états ne serait-ce que sur la partie graphique.
    </p>
    <figure>
        <figcaption>Vidéo de démonstration</figcaption>
        <video controls width="80%">
            <source src="/common/assets/projects/ThomasChronicles.mp4" type="video/mp4">
        </video>
    </figure>
</details>

<details>
    <summary>Modi (QiOVA)<span class="tags">[C++] [Électronique]</span></summary>
    <p>
        Lors de mon stage à QiOVA, j'ai été chargé de créer un circuit électronique nommé Modi permettant
        de tester la QELec (un produit commercialisé par QiOVA), simplement et automatiquement.
        Pour cela, il doit mesurer la fréquence d'un signal TOR, la tension d'un signal analogique, la durée d'une impulsion...
        et il doit être pilotable via une liaison série en passant par Arduino. J'ai donc dû concevoir le circuit,
        trouver et commander les composants, programmer l'Arduino Uno pour qu'elle pilote les différents composants
        et qu'elle accepte des commandes via la liaison série, et tester le bon fonctionnement du circuit.
    </p>
    <figure>
        <img src="/common/assets/projects/modi.png"  width="80%"/>
    </figure>
</details>
<details>
    <summary>Corentin le Magnanime<span class="tags">[C++] [SFML]</span></summary>
    <p>
        En 2018, là aussi pour fêter l'anniversaire d'un ami, avec des amis, nous avons créé un jeu à son effigie : <strong>Corentin le Magnanime</strong>.
        Le jeu contient deux parties différentes, l'une étant un enchaînement de mini-jeux (à la <em>Wario Ware</em>),
        l'autre étant un <em>bullet hell</em> (esquive d'un grand nombre de protectiles, à la <em>Touhou</em>).
    </p><p>
        Nous avons utilisé C++ et la SFML. Je me suis occupé du menu principal et de la partie <em>bullet hell</em>.
        Les <em>bullet hell</em> étant un genre de jeu que j'apprécie particulièrement, cela a été un plaisir de
        pouvoir en créer un par moi-même. Notamment, les mouvements des ennemis et des projectiles étant assez recherchés,
        cela a demandé du travail pour paramétrer mathématiquement les trajectoires.
    </p>
    <figure>
        <figcaption>Vidéo de démonstration</figcaption>
        <video controls width="80%">
            <source src="/common/assets/projects/corentin_magnanime.mp4" type="video/mp4">
        </video>
    </figure>
</details>
